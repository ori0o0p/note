---
id: Clean Coders Lecture 10. Architecture
aliases: 클린 코더스 강의 10. 아키텍처
tags:
  - architecture/use-case/separation
  - architecture/delivery-mechanism/mvc
  - design/clean-code/refactoring
  - process/agile/decision-deferral
  - oop/ooad/use-case
  - data/database/deferred-decision
  - testing/test-double/file-system
  - architecture/domain-logic/decoupling
  - product/iteration/feedback
  - sustainability/change-resilience/coupling
author: 백명석
created_at: 2025-10-02 10:57
related: []
source: https://www.youtube.com/watch?v=sYPsm93qIkY&list=PL7pUrjEGbG8ZMPQ-XukPJsFyMeyvtGcnV&index=12&pp=iAQB
---

## **1. 3줄 요약 (3-line summary)**

- 아키텍처는 도구나 프레임워크가 아니라 시스템의 사용법과 유스케이스(Use Case)를 드러내는 구조여야 하며, 딜리버리 메커니즘(Delivery Mechanism)과 분리되어야 한다.
- 좋은 아키텍처는 프레임워크, UI, DB 등 상세 결정들을 가능한 한 늦게 연기(Decision Deferral)하여 정보가 충분해진 시점에 최소 비용으로 결정·변경할 수 있게 한다.
- 피트니스(FitNesse) 사례에서 데이터베이스 의존을 미루고 파일시스템(File System)·인메모리(In-Memory)로 핵심 추상화(Core Abstraction)를 구현함으로써, 유스케이스 중심의 도메인 로직을 절연(Decoupling)했다.

## **2. 하이라이트/개요 (Highlights/Summary)**

아키텍처(Architecture)는 “시스템이 무엇을 하는가”를 보여주는 사용법의 설계로 정의되며, 자바·스프링·톰캣·MVC 같은 재료나 딜리버리 메커니즘(Delivery Mechanism)을 나열하는 것이 아니다. 실제로 많은 ‘아키텍처 그림’이 프레임워크 버전, DB 레플리케이션 등 구현 상세를 강조하지만, 그것은 시스템의 목적과 유스케이스(Use Case)를 가리는 잘못된 접근으로 지적된다. 올바른 아키텍처는 액터(Actor)와 시스템 간 상호작용의 절차를 통해 기능적 목적을 드러내는 유스케이스 표현을 중심에 둔다.

강의는 의존성 절연과 결정 미루기(Decision Deferral)의 가치에 집중한다. 정보가 부족한 초기에는 DB·UI·프레임워크 등의 선택을 늦춰야 하며, 핵심 도메인 로직을 유스케이스로 독립시키면 변화에 강한 구조가 된다. 피트니스(FitNesse) 사례에서 위키 페이지(Wiki Page) 저장을 위해 즉시 DB를 선택하지 않고, 텍스트→HTML 변환과 저장 추상화를 먼저 확립한 뒤 인메모리 페이지(In-Memory Page)와 파일시스템 기반 저장으로 기능을 만족시켰다. 고객 정책상 ‘모든 데이터는 실제 DB에 존재’ 요구가 발생하기 전까지 DB 결정을 연기함으로써, 변경 비용을 최소화하고 도메인 로직의 순수성을 유지했다.

## **3. 상세 요약 (Detailed Summary)**

### **아키텍처의 정의와 오해 (Architecture)**

- 아키텍처는 도구나 재료의 집합이 아니라 사용법을 드러내는 설계다(예: 예배당 설계도는 제대·좌석 배치로 ‘사용법’을 보여준다). 자바(Eclipse/Java), 스프링(Spring), 톰캣(Tomcat), MySQL, MVC 등은 재료·도구이지 아키텍처 그 자체가 아니다.
- 많은 ‘아키텍처 문서’가 프레임워크 버전, DB 구성 등 딜리버리 메커니즘(Delivery Mechanism)을 자세히 다루면서, 시스템의 목적과 기능을 드러내는 사용법을 가린다. 이는 시스템이 무엇을 하는지를 이해·검증·변경하기 어렵게 만든다.

### **유스케이스 중심 설계 (Use Case)**

- 유스케이스(Use Case)는 액터(Actor)와 시스템 간 상호작용 절차를 통해 특정 목적 달성 과정을 기술하는 가장 엄격하고 명확한 형식이다. OOAD(Object-Oriented Analysis & Design)에서 오랜 기간 핵심으로 사용되어 왔다.
- 액터 찾기(예: 게시판 시스템의 글쓰기/읽기/추천/운영자 등)와 각 액터가 사용하는 기능 도출을 통해 유스케이스를 구성한다. “사용자가 무엇을 하면 시스템은 무엇을 한다”는 단계적 상호작용으로 절차를 정형화한다.

### **딜리버리 메커니즘과 분리 (Delivery Mechanism)**

- 아키텍처는 유스케이스와 딜리버리 메커니즘(Delivery Mechanism: 예, MVC)을 강하게 커플링하지 않아야 한다. UI·DB·프레임워크·툴은 유스케이스와 절연되어야 하며, 유스케이스만으로도 존재·검증 가능해야 한다.
- MVC(Model-View-Controller) 상세에 집착하면, 시스템의 ‘무엇’보다 ‘어떻게 전달하는가’에 쏠려 본질을 흐린다. 유스케이스 중심으로 도메인 로직을 표현하고, 딜리버리는 교체 가능한 외부 구성 요소로 다룬다.

### **결정 미루기와 피트니스 사례 (Decision Deferral)**

- 결정 미루기(Decision Deferral)는 정보가 충분해질 때까지 상세 결정을 연기하는 원칙이다. 초기 예측 불가능성과 요구 변화에 대응해 변경 비용을 최소화한다.
- 피트니스(FitNesse)에서 ‘지금 당장 DB는 필요 없다’는 판단 하에 위키 텍스트→HTML 변환과 저장 추상화가 핵심임을 확인하고, 인메모리 페이지(In-Memory Page, 해시테이블 기반 키/값 저장)로 여러 페이지를 지원, 이어서 파일시스템(File System) 저장을 구현했다.
- 고객 정책으로 ‘모든 데이터는 실제 DB에 존재’ 요구가 등장한 후에야 MySQL 저장을 추가했다. 핵심 추상화를 먼저 확립하고 저장 매체를 교체 가능하게 유지함으로써 도메인 로직과 저장 구현의 의존성을 느슨하게 했다.
- [불확실성: 일부 인명·세부 구현 명칭은 음성 인식 오류로 변형되었을 가능성이 있음]

### **핵심 추상화와 데이터베이스의 위치 (Core Abstraction)**

- 많은 개발자가 DB·스키마를 가장 핵심으로 간주하지만, 애플리케이션 개발에서 진정한 핵심은 행동(Behavior)·기능의 동작이며, 데이터는 외부 가치 판단에서는 중요하더라도 소스 코드 의존성의 관점에서 핵심 추상화가 아니다.
- DB 중심으로 시작하면 절차적 설계로 경도되어 후반 변경이 어려워진다. 유스케이스 중심의 핵심 추상화를 우선 정립하고, 저장소 선택은 연기·교체 가능하도록 분리해야 한다.

### **변경 수용과 테스트 (Testing)**

- 빠른 검증을 위한 ‘더럽게’ 만든 초기 프로토타입은 반드시 폐기하고, 학습을 바탕으로 새로 ‘깨끗하게’ 만든다. 즉, MVP 단계의 코드와 제품 단계의 코드 목적을 혼동하지 않는다.
- 테스트 더블(Test Double: Mock/Subclass 등)을 활용해 외부 의존 없이 핵심 로직을 검증한다. 프레임워크·DB 의존성 없이 자바 코드 단에서 변경의 영향과 회귀를 빠르게 확인할 수 있어 변경 비용을 줄인다.
- [불확실성: 구체적 테스트 더블 구현 예시는 강의에서 개념적 수준으로 소개됨]

## **4. 결론 및 전문가 견해 (Conclusion and Professional View)**

- **유스케이스 중심:** 아키텍처의 1원리는 유스케이스(Use Case)로 도메인 로직을 표면화하고, 딜리버리·저장소·프레임워크를 주변화한다.
- **결정 연기:** 정보 축적 전에는 상세 선택(DB·UI·FW)을 연기해 변경 비용 우위를 확보한다.
- **의존성 절연:** 핵심 추상화와 외부 상세를 디커플링하여 지속가능(Sustainable)한 변경 수용성을 확보한다.
- **행동 우선:** 데이터보다 행동(Behavior)과 목적 달성 절차를 코드 의존성의 중심에 둔다.
- **프로토타입 폐기:** 학습용 빠른 제작물은 폐기하고, 리팩토링(Clean Code Principles)에 근거해 재구축한다.
- **테스트 가능 구조:** 테스트 더블을 활용해 도메인 로직을 독립 검증 가능한 구조로 유지한다(변경 회귀 비용 최소화).
- **절차적 함정 회피:** DB·스키마 선행 설계로 인한 절차지향 경도와 후반 난이도 급증을 회피한다.
- **조직·프로세스 적합:** 피드백 수용·론칭 유연성 등 애자일(Agile) 운영과 정렬된다(마감 고정으로 피드백 무시의 위험 경고).

## **5. 불확실성 지도 (Uncertainty Map)**

- **원본 모호성:** 음성 인식으로 일부 용어·인명(예: ‘마이크 패스’, ‘제시/이제훈’)이 왜곡되었을 가능성. 구체 코드·클래스 구조는 개념적 설명에 머물러 상세가 생략됨.
- **판단 근거:** 섹션 구분은 강의의 논리 흐름(정의→유스케이스→분리→결정 연기→핵심 추상화→변경·테스트)에 따라 재구성. 유스케이스를 중심축으로 배치하여 OOAD·변경 용이성 연결을 강화.
- **해석 불확실성:** ‘데이터가 중요하지 않다’는 취지가 외부 비즈니스 가치가 아닌 ‘소스 코드 의존성·핵심 추상화’ 관점임을 전제했으나, 자료만으로 경계가 완전하진 않음.
- **단순화/추상화 영역:** FitNesse 저장 경로의 전환(인메모리→파일→DB)을 개념적 단계로 요약했으며, 트랜잭션·동시성·일관성·장애 복구 등 운영상 세부는 생략됨.
- **의견 전환 질문:**
    - 고객 정책·규제 요건이 초기부터 강제될 때, 유스케이스 중심 아키텍처는 어떤 최소 의존성으로 합법·컴플라이언스를 만족할 것인가?
    - 대규모 트래픽·일관성 요구에서 파일시스템→DB 전환의 경계 조건과 성능·가용성 관점에서 결정 연기의 한계는 어디인가?
